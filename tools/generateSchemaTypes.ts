import { compile, JSONSchema } from 'json-schema-to-typescript'
import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

/**
 * Generate TypeScript types from JSON Schema files
 *
 * Naming conventions:
 * - All types prefixed with SURef
 * - objects.schema definitions: SURefMeta<SingularName> (e.g., SURefMetaDamage)
 * - Main schema types: SURef<SingularName> (e.g., SURefAbility)
 * - Arrays: SURef<PluralName>List (e.g., SURefAbilityList)
 */

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const SCHEMAS_DIR = path.join(__dirname, '../schemas')
const SHARED_DIR = path.join(SCHEMAS_DIR, 'shared')
const OUTPUT_FILE = path.join(__dirname, '../lib/types/generated.ts')

// Mapping from schema file names to singular entity names
const SCHEMA_NAME_MAP: Record<string, string> = {
  abilities: 'Ability',
  'ability-tree-requirements': 'AbilityTreeRequirement',
  'bio-titans': 'BioTitan',
  chassis: 'Chassis',
  'classes.advanced': 'AdvancedClass',
  'classes.core': 'CoreClass',
  'classes.hybrid': 'HybridClass',
  'crawler-bays': 'CrawlerBay',
  'crawler-tech-levels': 'CrawlerTechLevel',
  crawlers: 'Crawler',
  creatures: 'Creature',
  drones: 'Drone',
  equipment: 'Equipment',
  keywords: 'Keyword',
  meld: 'Meld',
  modules: 'Module',
  npcs: 'Npc',
  'roll-tables': 'RollTable',
  squads: 'Squad',
  systems: 'System',
  traits: 'Trait',
  vehicles: 'Vehicle',
}

// Mapping for objects.schema definitions to singular names
const OBJECTS_META_MAP: Record<string, string> = {
  action: 'Action',
  choice: 'Choice',
  choices: 'Choices',
  damage: 'Damage',
  entry: 'Entry',
  npc: 'Npc',
  stats: 'Stats',
  system: 'System',
  table: 'Table',
  traits: 'Traits',
}

// Capitalize first letter
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

async function generateTypes() {
  console.log('üîß Generating TypeScript types from JSON Schema...\n')

  const typeDefinitions: string[] = []

  // Header
  typeDefinitions.push('/**')
  typeDefinitions.push(' * Auto-generated TypeScript types from JSON Schema')
  typeDefinitions.push(' * DO NOT EDIT MANUALLY')
  typeDefinitions.push(' * Generated by tools/generateSchemaTypes.ts')
  typeDefinitions.push(' */\n')

  // Step 1: Generate types for shared schemas
  console.log('üìö Processing shared schemas...')

  // Process common.schema.json
  // Skip simple primitive wrappers - only generate types that add value (like enums)
  const commonSchemaPath = path.join(SHARED_DIR, 'common.schema.json')
  const commonSchema = JSON.parse(fs.readFileSync(commonSchemaPath, 'utf8'))

  // List of common definitions to skip (simple primitive wrappers with no utility)
  const skipCommonTypes = new Set([
    'id',
    'name',
    'nonNegativeInteger',
    'positiveInteger',
    'techLevel',
    'salvageValue',
    'hitPoints',
    'structurePoints',
  ])

  typeDefinitions.push('// ============================================')
  typeDefinitions.push('// Common Type Definitions')
  typeDefinitions.push('// ============================================\n')

  for (const [defName, defSchema] of Object.entries(
    (commonSchema.definitions as Record<string, JSONSchema>) || {}
  )) {
    // Skip simple primitive wrappers
    if (skipCommonTypes.has(defName)) {
      continue
    }

    const typeName = `SURef${capitalize(defName)}`

    // Create a standalone schema with all definitions for proper $ref resolution
    const standaloneSchema = {
      ...defSchema,
      definitions: commonSchema.definitions,
    }

    const compiled = await compile(standaloneSchema, typeName, {
      bannerComment: '',
      declareExternallyReferenced: false,
      additionalProperties: false, // Treat all schemas as closed by default
    })
    typeDefinitions.push(compiled.trim())
  }

  // Process enums.schema.json
  const enumsSchemaPath = path.join(SHARED_DIR, 'enums.schema.json')
  const enumsSchema = JSON.parse(fs.readFileSync(enumsSchemaPath, 'utf8'))

  typeDefinitions.push('\n// ============================================')
  typeDefinitions.push('// Enum Type Definitions')
  typeDefinitions.push('// ============================================\n')

  for (const [defName, defSchema] of Object.entries(
    enumsSchema.definitions || {}
  )) {
    const typeName = `SURef${capitalize(defName)}`
    const compiled = await compile(
      defSchema as unknown as JSONSchema,
      typeName,
      {
        bannerComment: '',
        declareExternallyReferenced: false,
        additionalProperties: false, // Treat all schemas as closed by default
      }
    )
    typeDefinitions.push(compiled.trim())
  }

  // Process objects.schema.json - these become SURefMeta* types
  const objectsSchemaPath = path.join(SHARED_DIR, 'objects.schema.json')
  const objectsSchema = JSON.parse(fs.readFileSync(objectsSchemaPath, 'utf8'))

  typeDefinitions.push('\n// ============================================')
  typeDefinitions.push('// Meta Object Type Definitions')
  typeDefinitions.push('// ============================================\n')

  const helperTypes = [
    'Traits',
    'Choices',
    'Choice',
    'Entry',
    'System',
    'Action',
    'Npc',
    'Table',
    'Damage',
    'Stats',
  ]

  for (const [defName, defSchema] of Object.entries(
    (objectsSchema.definitions as Record<string, JSONSchema>) || {}
  )) {
    const singularName = OBJECTS_META_MAP[defName] || capitalize(defName)
    const typeName = `SURefMeta${singularName}`

    // Create a standalone schema for compilation
    const standaloneSchema = {
      ...defSchema,
      definitions: objectsSchema.definitions,
    }

    const compiled = await compile(standaloneSchema, typeName, {
      bannerComment: '',
      declareExternallyReferenced: false,
      cwd: SHARED_DIR,
      additionalProperties: false, // Treat all schemas as closed by default
    })

    // Replace helper type references with SURefMeta* versions
    let processedOutput = compiled.trim()
    for (const helperType of helperTypes) {
      const metaType = `SURefMeta${helperType}`
      processedOutput = processedOutput.replace(
        new RegExp(`\\b${helperType}\\b`, 'g'),
        metaType
      )
    }

    typeDefinitions.push(processedOutput)
  }

  // Step 2: Generate types for main schemas
  console.log('\nüìã Processing main schemas...')

  typeDefinitions.push('\n// ============================================')
  typeDefinitions.push('// Main Entity Type Definitions')
  typeDefinitions.push('// ============================================\n')

  const schemaFiles = fs
    .readdirSync(SCHEMAS_DIR)
    .filter((f) => f.endsWith('.schema.json') && f !== 'index.json')
    .sort()

  for (const schemaFile of schemaFiles) {
    const schemaPath = path.join(SCHEMAS_DIR, schemaFile)
    const schemaName = schemaFile.replace('.schema.json', '')
    const singularName = SCHEMA_NAME_MAP[schemaName]

    if (!singularName) {
      console.log(`‚ö†Ô∏è  Skipping ${schemaFile} - no mapping found`)
      continue
    }

    console.log(`   Processing ${schemaFile} ‚Üí SURef${singularName}`)

    const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'))

    // The main type name - override the schema title
    const typeName = `SURef${singularName}`

    // Extract the items definition if this is an array schema
    // This creates singular types instead of array types
    let schemaToCompile
    if (schema.type === 'array' && schema.items) {
      schemaToCompile = {
        ...schema.items,
        title: typeName,
        definitions: schema.definitions, // Preserve any definitions
      }
    } else {
      schemaToCompile = {
        ...schema,
        title: typeName,
      }
    }

    try {
      const compiled = await compile(schemaToCompile, typeName, {
        bannerComment: '',
        declareExternallyReferenced: false, // Inline all types to avoid duplicates
        cwd: SCHEMAS_DIR,
        additionalProperties: false, // Treat all schemas as closed by default
        $refOptions: {
          resolve: {
            // Custom resolver for shared schemas
            file: {
              read: (file: { url: string }) => {
                const filePath = file.url.replace('file://', '')
                return fs.readFileSync(filePath, 'utf8')
              },
            },
          },
        },
      })

      // Remove duplicate type declarations by using SURefMeta* types for helper references
      let processedOutput = compiled.trim()

      const helperTypes = [
        'Traits',
        'Choices',
        'Choice',
        'Entry',
        'System',
        'Action',
        'Npc',
        'Table',
        'Damage',
        'Stats',
      ]

      // Replace all occurrences of helper type names with SURefMeta* versions
      for (const helperType of helperTypes) {
        const metaType = `SURefMeta${helperType}`

        // Replace type/interface declarations (these shouldn't exist in main schemas, but just in case)
        processedOutput = processedOutput.replace(
          new RegExp(`export type ${helperType} =`, 'g'),
          `export type ${metaType} =`
        )
        processedOutput = processedOutput.replace(
          new RegExp(`export interface ${helperType}`, 'g'),
          `export interface ${metaType}`
        )

        // Replace all references (with word boundaries to avoid partial matches)
        processedOutput = processedOutput.replace(
          new RegExp(`\\b${helperType}\\b`, 'g'),
          metaType
        )
      }

      typeDefinitions.push(`// ${singularName}`)
      typeDefinitions.push(processedOutput)
      typeDefinitions.push('')
    } catch (error) {
      console.error(`‚ùå Error processing ${schemaFile}:`, error)
    }
  }

  // Add helper union types at the end
  // Note: SURefSchemaName is now auto-generated from enums.schema.json#/definitions/schemaName

  // Generate SURefEntity from SCHEMA_NAME_MAP values
  const entityTypes = Object.values(SCHEMA_NAME_MAP)
    .sort()
    .map((name) => `  | SURef${name}`)
    .join('\n')

  const helperUnionTypes = `
// ============================================
// Helper Union Types
// ============================================

/**
 * Union of all file-level schema entity types
 */
export type SURefEntity =
${entityTypes}

/**
 * Union of all valid meta schema names (includes actions)
 * Note: SURefSchemaName is auto-generated from enums.schema.json
 */
export type SURefMetaSchemaName = SURefSchemaName | 'actions'

/**
 * Union of all meta entity types (includes actions)
 */
export type SURefMetaEntity = SURefEntity | SURefMetaAction
`

  typeDefinitions.push(helperUnionTypes)

  // Write output file
  const output = typeDefinitions.join('\n')
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8')

  console.log(`\n‚úÖ Types generated successfully!`)
  console.log(`üìÑ Output: ${OUTPUT_FILE}`)
}

// Run the generator
generateTypes().catch((error) => {
  console.error('‚ùå Type generation failed:', error)
  process.exit(1)
})
