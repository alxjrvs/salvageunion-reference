import { compile, JSONSchema } from 'json-schema-to-typescript'
import * as fs from 'fs'
import * as path from 'path'
import { SCHEMA_NAME_MAP } from './schemaNameMap.js'
import { getDirname, capitalize } from './generatorUtils.js'

/**
 * Generate TypeScript types from JSON Schema files
 *
 * Naming conventions:
 * - All types prefixed with SURef
 * - objects.schema definitions: SURefMeta<SingularName> (e.g., SURefMetaDamage)
 * - Main schema types: SURef<SingularName> (e.g., SURefAbility)
 * - Arrays: SURef<PluralName>List (e.g., SURefAbilityList)
 */

const __dirname = getDirname(import.meta.url)
const SCHEMAS_DIR = path.join(__dirname, '../schemas')
const SHARED_DIR = path.join(SCHEMAS_DIR, 'shared')
const OUTPUT_FILE = path.join(__dirname, '../lib/types/generated.ts')

// Derive objects.schema definitions from the schema file itself
function getObjectsMetaMap(): Record<string, string> {
  const objectsSchemaPath = path.join(SHARED_DIR, 'objects.schema.json')
  const objectsSchema = JSON.parse(fs.readFileSync(objectsSchemaPath, 'utf8'))

  const map: Record<string, string> = {}

  // Special cases for objects.schema definitions
  const specialCases: Record<string, string> = {
    npc: 'Npc', // Keep as Npc (not NPC) for objects definition
  }

  for (const defName of Object.keys(objectsSchema.definitions || {})) {
    // Use special cases if available, otherwise capitalize the definition name
    map[defName] = specialCases[defName] || capitalize(defName)
  }

  return map
}

// Derive list of simple primitive types to skip from common.schema
function getSkipCommonTypes(): Set<string> {
  const commonSchemaPath = path.join(SHARED_DIR, 'common.schema.json')
  const commonSchema = JSON.parse(
    fs.readFileSync(commonSchemaPath, 'utf8')
  ) as {
    definitions?: Record<string, unknown>
  }

  const skip = new Set<string>()

  for (const [defName, defSchema] of Object.entries(
    commonSchema.definitions || {}
  )) {
    const schema = defSchema as Record<string, unknown>

    // Skip if it's just a simple type wrapper (type: integer/string with no complex structure)
    if (schema.type && !schema.oneOf && !schema.anyOf && !schema.allOf) {
      // Also skip if it just has a $ref to another simple type
      if (!schema.properties && !schema.items) {
        skip.add(defName)
      }
    }
  }

  return skip
}

async function generateTypes() {
  console.log('🔧 Generating TypeScript types from JSON Schema...\n')

  const typeDefinitions: string[] = []

  // Header
  typeDefinitions.push('/**')
  typeDefinitions.push(' * Auto-generated TypeScript types from JSON Schema')
  typeDefinitions.push(' * DO NOT EDIT MANUALLY')
  typeDefinitions.push(' * Generated by tools/generateSchemaTypes.ts')
  typeDefinitions.push(' */\n')

  // Derive metadata from schemas
  const OBJECTS_META_MAP = getObjectsMetaMap()
  const skipCommonTypes = getSkipCommonTypes()

  // Step 1: Generate types for shared schemas
  console.log('📚 Processing shared schemas...')

  // Process common.schema.json
  // Skip simple primitive wrappers - only generate types that add value (like enums)
  const commonSchemaPath = path.join(SHARED_DIR, 'common.schema.json')
  const commonSchema = JSON.parse(fs.readFileSync(commonSchemaPath, 'utf8'))

  typeDefinitions.push('// ============================================')
  typeDefinitions.push('// Common Type Definitions')
  typeDefinitions.push('// ============================================\n')

  for (const [defName, defSchema] of Object.entries(
    (commonSchema.definitions as Record<string, JSONSchema>) || {}
  )) {
    // Skip simple primitive wrappers
    if (skipCommonTypes.has(defName)) {
      continue
    }

    const typeName = `SURef${capitalize(defName)}`

    // Create a standalone schema with all definitions for proper $ref resolution
    const standaloneSchema = {
      ...defSchema,
      definitions: commonSchema.definitions,
    }

    const compiled = await compile(standaloneSchema, typeName, {
      bannerComment: '',
      declareExternallyReferenced: false,
      additionalProperties: false, // Treat all schemas as closed by default
    })
    typeDefinitions.push(compiled.trim())
  }

  // Process enums.schema.json
  const enumsSchemaPath = path.join(SHARED_DIR, 'enums.schema.json')
  const enumsSchema = JSON.parse(fs.readFileSync(enumsSchemaPath, 'utf8'))

  typeDefinitions.push('\n// ============================================')
  typeDefinitions.push('// Enum Type Definitions')
  typeDefinitions.push('// ============================================\n')

  for (const [defName, defSchema] of Object.entries(
    enumsSchema.definitions || {}
  )) {
    const typeName = `SURef${capitalize(defName)}`
    const compiled = await compile(
      defSchema as unknown as JSONSchema,
      typeName,
      {
        bannerComment: '',
        declareExternallyReferenced: false,
        additionalProperties: false, // Treat all schemas as closed by default
      }
    )
    typeDefinitions.push(compiled.trim())
  }

  // Process objects.schema.json - these become SURefMeta* types
  const objectsSchemaPath = path.join(SHARED_DIR, 'objects.schema.json')
  const objectsSchema = JSON.parse(fs.readFileSync(objectsSchemaPath, 'utf8'))

  typeDefinitions.push('\n// ============================================')
  typeDefinitions.push('// Meta Object Type Definitions')
  typeDefinitions.push('// ============================================\n')

  const helperTypes = [
    'Traits',
    'Choices',
    'Choice',
    'Entry',
    'System',
    'Action',
    'Npc',
    'Table',
    'Damage',
    'Stats',
  ]

  for (const [defName, defSchema] of Object.entries(
    (objectsSchema.definitions as Record<string, JSONSchema>) || {}
  )) {
    const singularName = OBJECTS_META_MAP[defName] || capitalize(defName)
    const typeName = `SURefMeta${singularName}`

    // Create a standalone schema for compilation
    const standaloneSchema = {
      ...defSchema,
      definitions: objectsSchema.definitions,
    }

    const compiled = await compile(standaloneSchema, typeName, {
      bannerComment: '',
      declareExternallyReferenced: false,
      cwd: SHARED_DIR,
      additionalProperties: false, // Treat all schemas as closed by default
    })

    // Replace helper type references with SURefMeta* versions
    let processedOutput = compiled.trim()
    for (const helperType of helperTypes) {
      const metaType = `SURefMeta${helperType}`
      processedOutput = processedOutput.replace(
        new RegExp(`\\b${helperType}\\b`, 'g'),
        metaType
      )
    }

    typeDefinitions.push(processedOutput)
  }

  // Step 2: Generate types for main schemas
  console.log('\n📋 Processing main schemas...')

  typeDefinitions.push('\n// ============================================')
  typeDefinitions.push('// Main Entity Type Definitions')
  typeDefinitions.push('// ============================================\n')

  const schemaFiles = fs
    .readdirSync(SCHEMAS_DIR)
    .filter((f) => f.endsWith('.schema.json') && f !== 'index.json')
    .sort()

  for (const schemaFile of schemaFiles) {
    const schemaPath = path.join(SCHEMAS_DIR, schemaFile)
    const schemaName = schemaFile.replace('.schema.json', '')
    const singularName = SCHEMA_NAME_MAP[schemaName]

    if (!singularName) {
      console.log(`⚠️  Skipping ${schemaFile} - no mapping found`)
      continue
    }

    console.log(`   Processing ${schemaFile} → SURef${singularName}`)

    const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'))

    // The main type name - override the schema title
    const typeName = `SURef${singularName}`

    // Extract the items definition if this is an array schema
    // This creates singular types instead of array types
    let schemaToCompile
    if (schema.type === 'array' && schema.items) {
      schemaToCompile = {
        ...schema.items,
        title: typeName,
        definitions: schema.definitions, // Preserve any definitions
      }
    } else {
      schemaToCompile = {
        ...schema,
        title: typeName,
      }
    }

    try {
      const compiled = await compile(schemaToCompile, typeName, {
        bannerComment: '',
        declareExternallyReferenced: false, // Inline all types to avoid duplicates
        cwd: SCHEMAS_DIR,
        additionalProperties: false, // Treat all schemas as closed by default
        $refOptions: {
          resolve: {
            // Custom resolver for shared schemas
            file: {
              read: (file: { url: string }) => {
                const filePath = file.url.replace('file://', '')
                return fs.readFileSync(filePath, 'utf8')
              },
            },
          },
        },
      })

      // Remove duplicate type declarations by using SURefMeta* types for helper references
      let processedOutput = compiled.trim()

      // Derive helper types from OBJECTS_META_MAP (these are the shared object definitions)
      const helperTypes = Object.values(OBJECTS_META_MAP)

      // Replace all occurrences of helper type names with SURefMeta* versions
      for (const helperType of helperTypes) {
        const metaType = `SURefMeta${helperType}`

        // Replace type/interface declarations (these shouldn't exist in main schemas, but just in case)
        processedOutput = processedOutput.replace(
          new RegExp(`export type ${helperType} =`, 'g'),
          `export type ${metaType} =`
        )
        processedOutput = processedOutput.replace(
          new RegExp(`export interface ${helperType}`, 'g'),
          `export interface ${metaType}`
        )

        // Replace all references (with word boundaries to avoid partial matches)
        processedOutput = processedOutput.replace(
          new RegExp(`\\b${helperType}\\b`, 'g'),
          metaType
        )
      }

      typeDefinitions.push(`// ${singularName}`)
      typeDefinitions.push(processedOutput)
      typeDefinitions.push('')
    } catch (error) {
      console.error(`❌ Error processing ${schemaFile}:`, error)
    }
  }

  // Add helper union types at the end
  // Note: SURefSchemaName is now auto-generated from enums.schema.json#/definitions/schemaName

  // Generate SURefEntity from SCHEMA_NAME_MAP values
  const entityTypes = Object.values(SCHEMA_NAME_MAP)
    .sort()
    .map((name) => `  | SURef${name}`)
    .join('\n')

  const helperUnionTypes = `
// ============================================
// Helper Union Types
// ============================================

/**
 * Union of all file-level schema entity types
 */
export type SURefEntity =
${entityTypes}

/**
 * Union of all valid meta schema names (includes actions)
 * Note: SURefSchemaName is auto-generated from enums.schema.json
 */
export type SURefMetaSchemaName = SURefSchemaName | 'actions'

/**
 * Union of all meta entity types (includes actions)
 */
export type SURefMetaEntity = SURefEntity | SURefMetaAction
`

  typeDefinitions.push(helperUnionTypes)

  // Write output file
  const output = typeDefinitions.join('\n')
  fs.writeFileSync(OUTPUT_FILE, output, 'utf8')

  console.log(`\n✅ Types generated successfully!`)
  console.log(`📄 Output: ${OUTPUT_FILE}`)
}

// Run the generator
generateTypes().catch((error) => {
  console.error('❌ Type generation failed:', error)
  process.exit(1)
})
